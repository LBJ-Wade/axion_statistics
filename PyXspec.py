#!/usr/bin/python

from xspec import *
import csv
import numpy as np
from pynfft import NFFT, Solver
import matplotlib.pyplot as plt
import sys, os, glob, gc, time
from fourier_functions import chisq
from scipy.optimize import curve_fit


os.chdir("/home/rummelm/Dropbox/Axion_Statistics/xspec_fakeit/2006")

Xset.chatter = 1
#Xset.chatter = 25

######################  Key Parameters #################################
# run number
runnumber = 14

# Instrument
#instrument = "XMM"
instrument = "Athena"

if instrument=="XMM":
    # Energy range for generated fake data
    minE = 1.5
    maxE = 4.5
    # Highest Fourier mode used in Fourier representation of residuals
    kmax = 8
    # Highest Fourier mode that is used for fitting
    Nfit = 8
    # Number of Poisson iterations for generating fake datasets
    # models with ALPs have less iterations than without because
    # we also loop about B-field generations
    NPoissonALPs = 50
    NPoissonNoALPs = 40*50

elif instrument=="Athena":
    # Energy range for generated fake data
    minE = 0.7
    maxE = 1.4
    # Highest Fourier mode used in Fourier representation of residuals
    kmax = 16
    # Highest Fourier mode that is used for fitting
    Nfit = 16
    # Athena: combine ncombine-data points to one, otherwise too many data points
    ncombine = 2
    # Number of Poisson iterations for generating fake datasets
    # models with ALPs have less iterations than without because
    # we also loop about B-field generations
    NPoissonALPs = 50
    NPoissonNoALPs = 40*50

else:
    print "ERROR: Instrument selected is neither XMM nor Athena!"
    sys.exit(0)

# Exposure time for fake date in seconds
TExp = 500000.

# Currently using method II
ndrop = 0
# Number of high energy data points to drop
#ndrop = 50

############################ Xspec ######################################

# Define powerlaw model
def ALPGlob(engs, params, flux):
   for i in range(len(engs)-1):
      Aconst = params[0]
      val = 1. - 0.5*Aconst*( np.power(engs[i+1],2) + np.power(engs[i],2) )
      #Aconst = 1.0 - params[0]
      #val = math.pow(engs[i+1],Aconst)/Aconst - math.pow(engs[i],Aconst)/Aconst
      flux[i] = val

ALPGlobInfo = ("A   \"\"  0.001  0.0  0.0  0.01  0.01  0.00001",)

AllModels.addPyMod(ALPGlob, ALPGlobInfo, 'mul')

#Model.showList()
#sys.exit(0)

# Energy range
energyrange = "**-"+str(minE)+" "+str(maxE)+"-**"

# Loop over all values of g, and B iterations
g_chisqred_0_list = []
g_chisq_Fourier_list = []
g_chisq_Fourier_E2weighting_list = []
g_chisq_Fourier_E4weighting_list = []
g_chisq_Fit_list = []

Nfiles = len(glob.glob("survivalProbs_*.mod"))
nfiles = 0

for filealp in glob.glob("survivalProbs_*.mod"):
#for filealp in glob.glob("survivalProbs_50e-13_24.mod"):
#for filealp in glob.glob("survivalProbs_0e-13_11.mod"):

    nfiles += 1
    print "mod file "+str(nfiles)+" of "+str(Nfiles)

    # Extract value of g from filename in units of 10^-13
    # ONLY works if less than 90 B fields are generated by mathematica!!
    gval = float(filealp[14:-11])
    #continue

    print("*************"+filealp+"*************")

    # Set initial guess for Fourier transform to zero
    #f_hat_guess = []

    # Loop over NPoisson statistics
    if gval != 0.:
        NPoisson = NPoissonALPs
    else:
        NPoisson = NPoissonNoALPs


    for iPoisson in range(NPoisson):


        s1 = Spectrum("pn_rebin_pi.fits")
        s1.background = "pn_bkg_pi.fits"
        s1.response.arf = "pn_arf.fits"
        #s1.response.rmf = "pn_rmf.fits"
        s1.ignore("**-0.9 10.0-**")

        m1 = Model("wabs * (zpowerlw + apec + zgauss)")
        m1.setPars("0.15,,0.13,0.13,0.17,0.17", 1.65, 0.0176, 1.6e-3, "0.8,,0.4,0.4,1.7,1.7", 1.0, 0.0176, 1.0e-4, 6.4, 0.01, 0.0176, 1.0e-4)
        m1(9).frozen = True
        m1(10).frozen = True

        Fit.nIterations = 100
        Fit.perform()

        nh = m1.wabs.nH.values[0]
        normline = m1.zgauss.norm.values[0]
        normpowerlaw = m1.zpowerlw.norm.values[0]
        indexpowerlaw = m1.zpowerlw.PhoIndex.values[0]
        #nh = 0.13
        #normpowerlaw = 1.8e-3
        #indexpowerlaw = 1.5
        #normline = 6.71e-6

        Plot.device = "plot_PyXspec_pn.ps/vcps"
        Plot.xAxis = "keV"
        Plot.background = True
        Plot.xLog = False
        Plot.yLog = True

        Plot("data ratio")

        #sys.exit()

        # Define ALP model
        m2 = Model("wabs * mtable{"+filealp+"} * (zpowerlw + zgauss)")
        m2.setPars(nh, 1.0, indexpowerlaw, 0.0176, normpowerlaw, 6.4, 0.01, 0.0176, normline)

        # Generate fake data with ALPs
        #print str(iPoisson)+" of "+str(NPoisson)+" Poisson realizations"
        if instrument=="XMM":
            fs1 = FakeitSettings("fakeALP", background="pn_bkg_pi.fits", exposure = TExp)
        elif instrument=="Athena":
            AllData.clear()
            #fs1 = FakeitSettings("fakeALP", response="xifu.rmf", arf="xifu.arf", background='none', exposure = TExp)
            fs1 = FakeitSettings("fakeALP", exposure = TExp)
            fs1.response = "xifu.rmf"
            fs1.arf = "xifu.arf"
        else:
            print "ERROR: Instrument selected is neither XMM nor Athena!"
            sys.exit(0)

        AllData.fakeit(1,fs1,noWrite=True)
        #AllData.fakeit(fs1,noWrite=True)
        AllData.ignore(energyrange)
        AllData.show()

        # Define model without ALPs but with global modulation caused by ALPs
        m3 = Model("wabs * ALPGlob * (zpowerlw + zgauss)")
        m3.setPars(nh, 0.01, indexpowerlaw, 0.0176,  normpowerlaw, 6.4, 0.01, 0.0176, normline)
        m3(1).frozen = True
        m3(6).frozen = True
        m3(7).frozen = True
        # Power law index is fixed!! Maybe not realistic for a real fit
        m3(3).frozen = True

        Fit.query = "yes"
        Fit.perform()
        #print Fit.statistic/Fit.dof
        #chi2_nofourier = Fit.statistic
        #sys.exit(0)

        # Save residuals of ALP model: r = A(omega) - M_a(omega)
        Plot("resid")
        xval = Plot.x(1,1)
        rval = Plot.y(1,1)
        rerrval = Plot.yErr(1,1)

        # Set A of ALPGlob to zero such that model m3 becomes M(omega)
        # F(omega) = r(omega)/M(omega)
        AllModels.setPars(m3, {2:0})
        Plot("data")
        Momega = np.array(Plot.model())
        rval = rval/Momega
        rerrval = rerrval/Momega
        

        # Athena: combine ncombine-data points to one, len(data) mod ncombine data points are thrown away!!
        if instrument=="Athena":
            xvalcomb = []
            rvalcomb = []
            rerrvalcomb = []
            for icomb in range(len(xval)/ncombine):
                xvalcomb.append(np.mean(xval[icomb*ncombine:(icomb+1)*ncombine]))
                rvalcomb.append(np.mean(rval[icomb*ncombine:(icomb+1)*ncombine]))
                # add the errors as squares and afterwards take square root
                rerrvalcomb.append(1./ncombine/ncombine*np.sum(np.power(rerrval[icomb*ncombine:(icomb+1)*ncombine],2)))
            xval = xvalcomb
            rval = rvalcomb
            rerrval = np.sqrt(rerrvalcomb)

        # Reduce data to an even number of elements if not the case already
        if np.fmod(len(xval),2) == 1:
            xval = xval[1:]
            rval = rval[1:]
            rerrval = rerrval[1:]

        # Define model without ALPs to get chisq of just powerlaw fit
        m4 = Model("wabs * (zpowerlw + zgauss)")
        m4.setPars(nh, indexpowerlaw, 0.0176,  normpowerlaw, 6.4, 0.01, 0.0176, normline)
        m4(1).frozen = True
        m4(5).frozen = True
        m4(6).frozen = True
        # Power law index is fixed!! Maybe not realistic for a real fit
        m4(2).frozen = True

        Fit.query = "yes"
        Fit.perform()
        #print Fit.statistic/Fit.dof
        dof0powerlaw = Fit.dof
        chisq0powerlaw = Fit.statistic
 

        #####################  Write data to file #############################
        """rows = zip(xval,rval)

        with open('resid_'+filealp[:-4]+'.dat', 'wb') as fileout:
            writer = csv.writer(fileout)
            for row in rows:
                writer.writerow(row)"""


        ######################### Fourier #################################

        # Prepare data for Fourier transform: nodes
        xval = np.array(xval)
        Einv =  1./xval


        Einv_max = np.amax(Einv)
        Einv_min = np.amin(Einv)


        nodes = np.asarray([(1.0*len(Einv)-1.)/(1.0*len(Einv))*(Einv[i]-Einv_min)/(Einv_max-Einv_min)-0.5 for i in range(len(Einv)) ])
        values = np.asarray(rval*Einv*Einv)
        valueserr = np.asarray(rerrval*Einv*Einv)

        #print Einv
        #print nodes
        #print values

        #print "Number of nodes: ", len(nodes)
        #print "Number of values: ", len(values)
        #sys.exit(0)

        # Fourier transform: initialization and precompute
        M = len(nodes)          # number of nodes
        N = len(nodes)          # number of Fourier coefficients

        f     = np.empty(M,     dtype=np.complex128)
        f_hat = np.empty([N,N], dtype=np.complex128)

        this_nfft = NFFT(N=[N,N], M=M)
        this_nfft.x = np.array([[node_i,0.] for node_i in nodes])
        this_nfft.precompute()
        #print "precompute done"

        this_nfft.f = f
        ret2=this_nfft.adjoint()
        #print "adjoint done"

        #print this_nfft.M  # number of nodes, complex typed
        #print this_nfft.N  # number of Fourier coefficients, complex typed
        #print this_nfft.x # nodes in [-0.5, 0.5), float typed


        this_solver = Solver(this_nfft)
        #print "Solver initialized"
        this_solver.y = values          # '''right hand side, samples.'''
        #print "y-values defined"
        """if iPoisson == 0:
            this_solver.f_hat_iter = f_hat # assign 0 as initial solution guess, if it's the first Poisson realization
        else:
            this_solver.f_hat_iter = f_hat_guess # assign Fourier transform of previous Poisson iteration otherwise"""

        this_solver.before_loop()       # initialize solver internals

        # Calculate Fourier transform: this_solver.f_hat_iter

        # shoot for an accuracy lower than a threshold value
        #while not np.all(this_solver.r_iter < 1e-3):
        #    this_solver.loop_one_step()

        #print "solver iterations start"
        # fix the number of iterations
        niter = 10 #20
        for iiter in range(niter):
            this_solver.loop_one_step()
            #print "solver iteration "+str(iiter)
            #print this_solver.f_hat_iter
        #print "solver done"

        #f_hat_guess = this_solver.f_hat_iter

        #print this_solver.f_hat_iter[0:3]
        #print "define f_hat_vals"
        f_hat_vals =[ this_solver.f_hat_iter[i][-1] for i in range(len(this_solver.f_hat_iter) ) ]

        #print "define arrtest"
        #arrtest = [ N*sum(f_hat_vals[i]*np.exp(-2*(np.pi)*(1.0j)*(i-N/2)*nodes[k]) for i in range(N) ) for k in range(M) ]

        # select fourier coefficients that are larger than threshold value times average of Fourier coefficients absolute value
        #thresh_val = 2.0
        #thresh_coeff = []
        #fhat_mean = np.mean(np.abs(f_hat_vals))
        #for i in range(N):
            #if np.abs(f_hat_vals[i]) > thresh_val*fhat_mean:
                #thresh_coeff.append([i,np.abs(f_hat_vals[i])])

        #print "values vs arrtest"
        #print values[10:13]
        #print np.real(arrtest[10:13])
        #print np.imag(arrtest[10:13])
        #print np.abs(f_hat_vals[0:20])
        #print thresh_coeff
        #print np.real(f_hat_vals[0:20])

        #################### Plot results #################################
        #yfourier = [ np.real( N*sum(f_hat_vals[i]*np.exp(-2*(np.pi)*(1.0j)*(i-N/2)*nodes[k]) for i in range(N/2-kmax,N/2+kmax) ) ) for k in range(M) ]
        #print "define yfourier"
        yfourier = [ np.real( N*sum(f_hat_vals[i]*np.exp(-2*(np.pi)*(1.0j)*(i-N/2)*nodes[k]) for i in range(N/2-kmax,N/2+1+kmax) ) ) for k in range(M) ]


        #print "define resid_fourier"
        def resid_fourier(Einvn,nlow,nup):
            return np.real( N*sum(f_hat_vals[i]*np.exp(-2*(np.pi)*(1.0j)*(i-N/2)*(  (1.0*M-1.)/(1.0*M)*(Einvn-Einv_min)/(Einv_max-Einv_min)-0.5) ) for i in range(nlow, nup) ) )
        #def resid_fourier(Einvn,nlow,nup):
            #return np.real( N*sum(f_hat_vals[i]*np.exp(-2*(np.pi)*(1.0j)*(i-N/2)*(  (1.0*M-1.)/(1.0*M)*(Einvn-Einv_min)/(Einv_max-Einv_min)-0.5) ) for i in range(N) ) )
        
        # for Plots
        Einvvals = np.arange(1./maxE,1./minE,0.00001)
        Evals = np.arange(minE,maxE,0.00001)
        rmax = np.amax(rval/xval/xval)
        rmin = np.amin(rval/xval/xval)
 
        # Fourier plots
        """fplot = plt.figure()
        plt.xlim((0.9*Einv_min,1.1*Einv_max))
        plt.ylim((2.3*rmin,2.3*rmax))
        plt.xlabel('1/E in 1/keV')
        plt.ylabel('Residuals/E^2')
        plt.plot(1./xval, rval/xval/xval, 'b+', Einvvals, resid_fourier(Einvvals,N/2-kmax,N/2+kmax), 'k')
        fplot.savefig("plot_ResVsFourier_InvE.pdf", bbox_inches='tight')
        #plt.plot((1./xval), (rval/xval/xval), 'b+', 1./xval, (rval/xval/xval)-yfourier, 'r*', [0.8*Einv_min, 1.2*Einv_max], [0.]*2, 'k--')
        #fplot.savefig("plot_ResVsImpRes_InvE.pdf", bbox_inches='tight')"""

        """fplot2 = plt.figure()
        plt.xlim((1.5,4.5))
        plt.ylim((3.0*rmin,3.0*rmax))
        plt.plot(xval, rval, 'bo', Evals, resid_fourier(1./Evals,N/2-kmax,N/2+1+kmax)*Evals*Evals, 'k')
        plt.xlabel('E in keV')
        plt.ylabel('Residuals')
        fplot2.savefig("plot_fourier_E.pdf", bbox_inches='tight')"""

        ############ Fit ##############
        def fitfunc(x, *p):
            return sum(p[i]*np.sin((i+1.)*2.*np.pi/(Einv_max-Einv_min)*x+p[i+Nfit]) for i in range(Nfit))

        popt, pcov = curve_fit(fitfunc, Einv, values, sigma=valueserr, p0=[0]*2*Nfit)
        #print popt

        # Fit plots
        """fplotFit = plt.figure()
        plt.xlabel('1/E in 1/keV')
        plt.ylabel('Residuals/E^2')
        plt.plot(Einv, values, 'b+')
        plt.plot(Einvvals, fitfunc(Einvvals, *popt), 'k')
        fplotFit.savefig("plot_Fit.pdf", bbox_inches='tight')"""
        """fplotFit = plt.figure()
        plt.xlabel('E in keV')
        plt.ylabel('Residuals/E^2')
        plt.plot(xval, values, 'b+')
        #plt.plot(1./Einv, values, 'r+')
        plt.plot(Evals, fitfunc(1./Evals, *popt), 'k')
        fplotFit.savefig("plot_Fit.pdf", bbox_inches='tight')"""


        # Calculate chi^2 and append data to g_chisq array
        # If ndrop not zero don't divide by E^2
        if ndrop != 0:
            yval = (rval/xval/xval)[:(-ndrop)]
            yerrval = (rerrval/xval/xval)[:(-ndrop)]
            #mval = resid_fourier(Einv,N/2-kmax,N/2+1+kmax)        
            mval = yfourier[:(-ndrop)]

        else:
            yval = rval/xval/xval
            yerrval = rerrval/xval/xval
            mval = yfourier

        #print resid_fourier(Einv,N/2-kmax,N/2+1+kmax)[3:8]      
        #print resid_fourier(1./xval,N/2-kmax,N/2+1+kmax)[3:8]
        #print mval[3:8]
        #sys.exit(0)

        # no-ALP fit to data
        #chisq0 = chisq0powerlaw
        chisq0 = chisq([0]*len(yval),yval,yerrval)
        # Fourier Analysis of residuals
        chisq_Fourier = chisq(mval,yval,yerrval)
        # Divide yfourier by E^2 to suppress high energy residuals where
        # the Fourier representation doesn't do a good job
        chisq_Fourier_E2weighting = chisq(mval/xval/xval,yval,yerrval)
        # Divide yfourier by E^4 to have even higher suppression at high energies
        chisq_Fourier_E4weighting = chisq(mval/xval/xval/xval/xval,yval,yerrval)
        
        #chisqtest = chisq(resid_fourier(Einv,N/2-kmax,N/2+1+kmax)*Einv*Einv,rval,rerrval)
        #print chisq_Fourier_E4weighting
        #print chisqtest
        #print chisq0
        #sys.exit(0)
        
        # Fit of residuals
        mfit = fitfunc(1./xval, *popt)
        chisq_Fit = chisq(mfit,yval,yerrval)

        """print "chisq0: "+str(chisq0)
        print "chisq_Fit: "+str(chisq_Fit)
        print "chisq without fit: "+str(chisq([0]*len(yval),yval,yerrval))
        #print "chisq with fit: "+str(chisq(mfit,values,yerrval))

        print mfit[:5]
        print values[:5]"""

        # Append chisquares to lists
        g_chisqred_0_list.append([gval,chisq0powerlaw/dof0powerlaw])
        g_chisq_Fourier_list.append([gval,chisq0-chisq_Fourier])
        g_chisq_Fourier_E2weighting_list.append([gval,chisq0-chisq_Fourier_E2weighting])
        g_chisq_Fourier_E4weighting_list.append([gval,chisq0-chisq_Fourier_E4weighting])
        g_chisq_Fit_list.append([gval,chisq0-chisq_Fit])


        """print "0-Method (red chisq): "+str(chisq0/dof0powerlaw)
        print "Fourier-Method:"+str(chisq0-chisq_Fourier)
        print "Fourier-Method (E^2 weighting):"+str(chisq0-chisq_Fourier_E2weighting)
        print "Fourier-Method (E^4 weighting):"+str(chisq0-chisq_Fourier_E4weighting)
        print "Fitting-Method:"+str(chisq0-chisq_Fit)"""


        """print "yval vs mval"
        print yval[10:13]
        print mval[10:13]
        print "chisq0 = "+str(chisq0)
        print "chisq1 = "+str(chisq1)
        time.sleep(5)"""


        AllData.clear()
        AllModels.clear()
        # Garbage collector
        gc.collect()


# Write results to file
#print "Results:"
np.savetxt('g_chisqred_0_'+str(instrument)+'_run'+str(runnumber)+'.txt',g_chisqred_0_list)
np.savetxt('g_chisq_Fourier_'+str(instrument)+'_run'+str(runnumber)+'.txt',g_chisq_Fourier_list)
np.savetxt('g_chisq_Fourier_E2weighting_'+str(instrument)+'_run'+str(runnumber)+'.txt',g_chisq_Fourier_E2weighting_list)
np.savetxt('g_chisq_Fourier_E4weighting_'+str(instrument)+'_run'+str(runnumber)+'.txt',g_chisq_Fourier_E4weighting_list)
np.savetxt('g_chisq_Fit_'+str(instrument)+'_run'+str(runnumber)+'.txt',g_chisq_Fit_list)


